PLAN ONLINE-FIRST - DIAGNOSTICO Y SOLUCION
Fecha: 2026-02-18
Proyecto: StockFacil

1) Problema detectado
La arquitectura actual no cumple completamente el objetivo "online primero, local solo fallback".

Hallazgos principales:
- Productos (empleador): se guardan primero en local y solo se suben con umbral o accion manual.
- Ventas offline: no hay reintento automatico global al volver internet (se sincronizan sobre todo en cierre de caja).
- Caja: se arma principalmente desde IndexedDB local; no hay pull de nube al abrir panel para asegurar consistencia entre dispositivos.
- Productos (pull): existe pull para empleado, pero no reconciliacion de borrados remotos ni estrategia unificada para todos los roles.

Impacto:
- Diferencias de datos entre pestañas/dispositivos.
- Productos/ventas pueden quedar pendientes sin sincronizar durante tiempo indefinido.
- Experiencia inconsistente para empleados cuando trabajan en otra pestaña/equipo.

2) Solucion que se implementara
Objetivo: mantener modo online-first con fallback local robusto y sincronizacion automatica al reconectar.

2.1 Productos
- En createProduct/updateProductStock/deleteProduct:
  - Si hay conexion + sesion Firebase valida, intentar backend primero (syncProducts/deleteProductByCode).
  - Si backend falla por red/servicio, guardar local como pending y mostrar mensaje de fallback.
- Al volver internet (evento online): ejecutar syncPendingProducts automaticamente.
- Pull desde nube para todos los roles al cargar stock.
- Reconciliacion de borrados:
  - comparar codigos locales vs nube y marcar/eliminar locales inexistentes en nube cuando corresponda.

2.2 Ventas
- Mantener backend-first actual para chargeSale.
- Agregar listener global de reconexion para ejecutar syncPendingSales automaticamente.
- Agregar sincronizacion oportunista adicional en init del panel cuando hay conexion.

2.3 Caja
- Mantener cierre con fallback local.
- Antes de renderizar caja, forzar syncPendingSales si hay conexion.
- Recalcular snapshot con datos sincronizados para evitar desfases entre usuarios/dispositivos.

2.4 Control de consistencia y observabilidad
- Unificar mensajes de estado: "online", "fallback local", "sincronizado".
- Registrar contadores de pendientes (productos/ventas) y mostrar feedback claro.
- Evitar sobrescrituras peligrosas: merge por codigo/producto y fecha de actualizacion.

3) Criterios de aceptacion
- Con internet activo, alta/edicion/baja de productos se refleja en nube en el momento.
- Si internet cae, operaciones quedan locales y al reconectar se sincronizan sin accion manual.
- Empleado en otra pestaña/equipo ve productos actualizados tras reconexion/sync.
- Caja refleja ventas sincronizadas y no queda atrasada respecto a nube.
- No se pierden operaciones offline pendientes.

4) Riesgos y mitigaciones
- Riesgo de duplicados en sync: usar claves estables (codigo/idVenta) y idempotencia en backend.
- Riesgo de conflictos local-remoto: priorizar timestamp actualizado y reglas claras por entidad.
- Riesgo de borrados accidentales: reconciliacion de borrados solo con confirmacion de fuente remota valida.

5) Orden de implementacion recomendado
1. Productos backend-first + sync en online.
2. Ventas sync automatica en reconexion e init.
3. Caja con pre-sync antes de snapshot.
4. Reconciliacion de borrados y ajustes de UX/feedback.

Fin del documento.
